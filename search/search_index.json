{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nagata","text":"Version Status Docs Compatibility Stats Tools"},{"location":"#what-is-nagata","title":"What is nagata?","text":"<p>[TODO: Brief summary of the project]</p>"},{"location":"#why-use-nagata","title":"Why use nagata?","text":"<p>[TODO: Features and reasons to use the project (and, possibly, not to use it)]</p>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#requirements","title":"Requirements","text":"<p>[TODO: List any OS or other restrictions and pre-installation dependencies]</p>"},{"location":"#installation","title":"Installation","text":"<p>To install <code>nagata</code>, use <code>pip</code>:</p> <pre><code>pip install nagata\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>[TODO: Describe common use cases, with possible example(s)]</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributors are always welcome. Feel free to grab an issue to work on or make a suggested improvement. If you wish to contribute, please read the Contribution Guide and Code of Conduct.</p>"},{"location":"#similar-projects","title":"Similar Projects","text":"<p>[TODO: If they exist, it is always nice to acknowledge other similar efforts]</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>[TODO: Mention any people or organizations that warrant a special acknowledgment]</p>"},{"location":"#license","title":"License","text":"<p>Use of this repository is authorized under the Apache Software License 2.0.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>0.1.0     Initial Commit</p>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting any of the following people:</p> <ul> <li>Corey Rayburn Yung (coreyrayburnyung@gmail.com)</li> </ul> <p>All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome and greatly appreciated! Every little bit helps, and credit will always be given. Environment Setup</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Follow this basic process:</p> <ol> <li>Fork and clone the repositor.</li> <li>Create a new branch: <code>git checkout -b feature-or-bugfix-name</code>.</li> <li>Edit the code.</li> <li>If you added functionality or features, update the documentation accordingly.</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"contributing/#style-guidelines","title":"Style Guidelines","text":"<p>This package follows the Google Python Style Guide with two notable exceptions:</p> <ol> <li>It always adds spaces around \"=\". This not only violates the Google guide, it violates PEP8, the foundational Python style guide from which all other resources are derived. I defy this strong, long-standign norm because I find it more readable. My brain and eyes have trouble seeing two separate objects when an equal sign is in the middle. I imagine that I am not alone in this accessibility issue. Further, as PEP8 itself notes, required spaces around equal signs are becoming increasing common with type annotations becoming part of best practices (and, as a result, signatures to classes, functions, and methods regularly include spaces around the equal signs). I realize that this will seem alien to many coders, but it is far easier on my eyes.</li> <li>I use some so-called \"power features\", primarily dunder methods, to make my interfaces easier to access and use. This is disfavored in the Google Python Style Guide because such code is often more difficult for others to read. To address that concern, I try to document and comment as to what the code is doing whenever I used any of the \"power features\" of Python.</li> </ol>"},{"location":"credits/","title":"Credits","text":"<p><p>These projects were used to build nagata. Thank you!</p> <p><code>python</code> | <code>pdm</code></p> </p>"},{"location":"credits/#exec-1--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>camina</code> Your Python project companion <code>&gt;= 0.1.16</code> <code>0.1.16</code> Apache-2.0 <code>miller</code> introspection tools using consistent, accessible syntax <code>&gt;= 0.1.6</code> <code>0.1.8</code> Apache-2.0"},{"location":"credits/#exec-1--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>babel</code> Internationalization utilities <code>&gt;=2.10.3</code> <code>2.12.1</code> BSD <code>beautifulsoup4</code> Screen-scraping library <code>4.12.2</code> MIT License <code>certifi</code> Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2023.7.22</code> MPL-2.0 <code>cfgv</code> Validate configuration and produce human readable error messages. <code>&gt;=2.0.0</code> <code>3.4.0</code> MIT <code>charset-normalizer</code> The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&lt;4,&gt;=2</code> <code>3.2.0</code> MIT <code>click</code> Composable command line interface toolkit <code>&gt;=7.0</code> <code>8.1.7</code> BSD-3-Clause <code>colorama</code> Cross-platform colored terminal text. <code>&gt;=0.4; platform_system == \"Windows\"</code> <code>0.4.6</code> BSD License <code>coverage</code> Code coverage measurement for Python <code>&gt;= 7.2.7</code> <code>7.3.0</code> Apache-2.0 <code>csscompressor</code> A python port of YUI CSS Compressor <code>&gt;=0.9.5</code> <code>0.9.5</code> BSD <code>cssselect</code> cssselect parses CSS3 Selectors and translates them to XPath 1.0 <code>&gt;=1.2.0</code> <code>1.2.0</code> BSD <code>distlib</code> Distribution utilities <code>&lt;1,&gt;=0.3.7</code> <code>0.3.7</code> PSF-2.0 <code>exceptiongroup</code> Backport of PEP 654 (exception groups) <code>&gt;=1.0.0rc8; python_version &lt; \"3.11\"</code> <code>1.1.3</code> ? <code>execnet</code> execnet: rapid multi-Python deployment <code>&gt;=1.1</code> <code>2.0.2</code> MIT License <code>filelock</code> A platform independent file lock. <code>&lt;4,&gt;=3.12.2</code> <code>3.12.3</code> The Unlicense (Unlicense) <code>ghp-import</code> Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License <code>gitdb</code> Git Object Database <code>&lt;5,&gt;=4.0.1</code> <code>4.0.10</code> BSD License <code>gitpython</code> GitPython is a Python library used to interact with Git repositories <code>3.1.32</code> BSD <code>griffe</code> Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. <code>&gt;=0.35</code> <code>0.35.2</code> ISC <code>htmlmin2</code> An HTML Minifier <code>&gt;=0.1.13</code> <code>0.1.13</code> BSD <code>identify</code> File identification library for Python <code>&gt;=1.0.0</code> <code>2.5.27</code> MIT <code>idna</code> Internationalized Domain Names in Applications (IDNA) <code>&lt;4,&gt;=2.5</code> <code>3.4</code> BSD License <code>iniconfig</code> brain-dead simple config-ini parsing <code>2.0.0</code> MIT License <code>jinja2</code> A very fast and expressive template engine. <code>&gt;=2.11.1</code> <code>3.1.2</code> BSD-3-Clause <code>jsmin</code> JavaScript minifier. <code>&gt;=3.0.1</code> <code>3.0.1</code> MIT License <code>lxml</code> Powerful and Pythonic XML processing library combining libxml2/libxslt with the ElementTree API. <code>&gt;=4.6</code> <code>4.9.3</code> BSD-3-Clause <code>markdown</code> Python implementation of John Gruber's Markdown. <code>&lt;4.0.0,&gt;=3.3.3</code> <code>3.4.4</code> BSD License <code>markdown-callouts</code> Markdown extension: a classier syntax for admonitions <code>&gt;= 0.3</code> <code>0.3.0</code> MIT <code>markdown-exec</code> Utilities to execute code blocks in Markdown files. <code>&gt;= 1.6.0</code> <code>1.6.0</code> ISC <code>markdown2</code> A fast and complete Python implementation of Markdown <code>&gt;=2.4.3</code> <code>2.4.10</code> MIT <code>markupsafe</code> Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0.1</code> <code>2.1.3</code> BSD-3-Clause <code>mergedeep</code> A deep merge function for \ud83d\udc0d. <code>&gt;=1.3.4</code> <code>1.3.4</code> MIT License <code>mkdocs</code> Project documentation with Markdown. <code>&gt;= 1.5.2</code> <code>1.5.2</code> BSD License <code>mkdocs-coverage</code> MkDocs plugin to integrate your coverage HTML report into your site. <code>&gt;= 1.0.0</code> <code>1.0.0</code> ISC <code>mkdocs-gen-files</code> MkDocs plugin to programmatically generate documentation pages during the build <code>&gt;= 0.5.0</code> <code>0.5.0</code> MIT License <code>mkdocs-git-committers-plugin-2</code> An MkDocs plugin to create a list of contributors on the page <code>&gt;= 1.1.2</code> <code>1.1.2</code> MIT <code>mkdocs-literate-nav</code> MkDocs plugin to specify the navigation in Markdown instead of YAML <code>&gt;= 0.6.0</code> <code>0.6.0</code> MIT License <code>mkdocs-material</code> Documentation that simply works <code>&gt;= 9.1.2</code> <code>9.2.5</code> MIT License <code>mkdocs-material-extensions</code> Extension pack for Python Markdown and MkDocs Material. <code>&gt;=1.1</code> <code>1.1.1</code> MIT License <code>mkdocs-minify-plugin</code> An MkDocs plugin to minify HTML, JS or CSS files prior to being written to disk <code>&gt;= 0.7.1</code> <code>0.7.1</code> MIT <code>mkdocstrings</code> Automatic documentation from sources, for MkDocs. <code>[python] &gt;= 0.22.0</code> <code>0.22.0</code> ISC <code>mkdocstrings-python</code> A Python handler for mkdocstrings. <code>&gt;=0.5.2</code> <code>1.6.0</code> ISC <code>nodeenv</code> Node.js virtual environment builder <code>&gt;=0.11.1</code> <code>1.8.0</code> BSD <code>packaging</code> Core utilities for Python packages <code>&gt;=20.5</code> <code>23.1</code> BSD License <code>paginate</code> Divides large result sets into pages for easier browsing <code>&gt;=0.5.6</code> <code>0.5.6</code> MIT <code>pathspec</code> Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.11.1</code> <code>0.11.2</code> Mozilla Public License 2.0 (MPL 2.0) <code>platformdirs</code> A small Python package for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=2.2.0</code> <code>3.10.0</code> MIT License <code>pluggy</code> plugin and hook calling mechanisms for python <code>&lt;2.0,&gt;=0.12</code> <code>1.3.0</code> MIT <code>pre-commit</code> A framework for managing and maintaining multi-language pre-commit hooks. <code>&gt;= 3.3.3</code> <code>3.3.3</code> MIT <code>pygments</code> Pygments is a syntax highlighting package written in Python. <code>&gt;=2.14</code> <code>2.16.1</code> BSD-2-Clause <code>pymdown-extensions</code> Extension pack for Python Markdown. <code>&gt;=9</code> <code>10.2.1</code> MIT License <code>pyquery</code> A jquery-like library for python <code>&gt;=1.2</code> <code>2.0.0</code> BSD <code>pytest</code> pytest: simple powerful testing with Python <code>&gt;= 7.4.0</code> <code>7.4.0</code> MIT <code>pytest-cov</code> Pytest plugin for measuring coverage. <code>&gt;= 4.1.0</code> <code>4.1.0</code> MIT <code>pytest-randomly</code> Pytest plugin to randomly order tests and control random.seed. <code>&gt;= 3.13.0</code> <code>3.15.0</code> MIT <code>pytest-xdist</code> pytest xdist plugin for distributed testing, most importantly across multiple CPUs <code>&gt;= 3.3.1</code> <code>3.3.1</code> MIT <code>python-dateutil</code> Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.8.2</code> Dual License <code>pyyaml</code> YAML parser and emitter for Python <code>&gt;=5.1</code> <code>6.0.1</code> MIT <code>pyyaml-env-tag</code> A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>0.1</code> MIT License <code>readtime</code> Calculates the time some text takes the average human to read, based on Medium's read time forumula <code>&gt;=2.0</code> <code>3.0.0</code> BSD <code>regex</code> Alternative regular expression module, to replace re. <code>&gt;=2022.4.24</code> <code>2023.8.8</code> Apache Software License <code>requests</code> Python HTTP for Humans. <code>2.31.0</code> Apache 2.0 <code>ruff</code> An extremely fast Python linter, written in Rust. <code>&gt;= 0.0.286</code> <code>0.0.286</code> MIT <code>setuptools</code> Easily download, build, install, upgrade, and uninstall Python packages <code>68.1.2</code> MIT License <code>six</code> Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.16.0</code> MIT <code>smmap</code> A pure Python implementation of a sliding window memory map manager <code>&lt;6,&gt;=3.0.1</code> <code>5.0.0</code> BSD <code>soupsieve</code> A modern CSS selector implementation for Beautiful Soup. <code>&gt;1.2</code> <code>2.4.1</code> MIT License <code>toml</code> Python Library for Tom's Obvious, Minimal Language <code>&gt;= 0.10.2</code> <code>0.10.2</code> MIT <code>tomli</code> A lil' TOML parser <code>; python_full_version &lt;= \"3.11.0a6\"</code> <code>2.0.1</code> ? <code>typing-extensions</code> Backported and Experimental Type Hints for Python 3.7+ <code>&gt;=4.7.1; python_version &lt; \"3.11\"</code> <code>4.7.1</code> ? <code>urllib3</code> HTTP library with thread-safe connection pooling, file post, and more. <code>&lt;3,&gt;=1.21.1</code> <code>2.0.4</code> MIT License <code>virtualenv</code> Virtual Python Environment builder <code>&gt;=20.10.0</code> <code>20.24.4</code> MIT License <code>watchdog</code> Filesystem events monitoring <code>&gt;=2.0</code> <code>3.0.0</code> Apache License 2.0"},{"location":"license/","title":"License","text":"<p>Apache Software License 2.0</p> <p>Copyright \u00a9 2023, Corey Rayburn Yung</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> nagata<ul> <li> core</li> <li> formats</li> <li> lazy</li> </ul> </li> </ul>"},{"location":"reference/nagata/","title":"Index","text":"<p>Python file management using a common, intuitive syntax</p>"},{"location":"reference/nagata/core/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> core","text":"<p>core: base classes for file management Corey Rayburn Yung coreyrayburnyung@gmail.com Copyright 2020-2022, Corey Rayburn Yung License: Apache-2.0</p> <pre><code>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> Contents <p>FileFormat (object): base class for defining rules and methods for different     file formats. FileFramework (object): Stores default settings, all file formats, and any     other shared information used by FileManager. FileManager (object): interface for nagata file management. It provides a     one-stop place for loading and saving all files of supported file types      in an organizational structure specified by the user.</p> <p>ToDo:</p>"},{"location":"reference/nagata/core/#nagata.core.FileFormat","title":"<code>FileFormat</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>File format information, loader, and saver.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the format name which should match the key when a FileFormat  instance is stored. 'name' is required so that the automatic  registration of all FileFormat instances works properly.</p> required <code>extensions</code> <code>Optional[Union[str, Sequence[str]]]</code> <p>str file extension(s) associated with the format. If more than one is listed, the first  one is used for saving new files and all will be used for loading.  Defaults to None.</p> <code>None</code> <code>loader</code> <code>str | FunctionType</code> <p>if a str, it is the name of the  loading method in 'module' to use, name of attribute of the loading method on the FileFormat instance, or the name of a method in the 'transfer' module of nagata. Otherwise, it should be a function for  loading.</p> required <code>saver</code> <code>str | FunctionType</code> <p>if a str, it is the name of the  saving method in 'module' to use, name of attribute of the saving method on the FileFormat instance, or the name of a method in the 'transfer' module of nagata. Otherwise, it should be a function for  saving.</p> required <code>module</code> <code>Optional[str]</code> <p>name of module where the relevant loader and  saver are located. If 'module' is None, nagata will first look to see if 'loader' or 'saver' is attached to the FileFormat instance and then check for a function in the 'transfer' module. Defaults to None.</p> required <code>parameters</code> <code>Mapping[str, str]]</code> <p>shared parameters to use from the pool  of settings in FileFramework.settings where the key is the parameter  name that the load or save method should use and the value is the  key for the argument in the shared parameters. Defaults to an empty  dict.</p> required"},{"location":"reference/nagata/core/#nagata.core.FileFormat.save_parameters","title":"<code>save_parameters: Optional[Mapping[str, str]] = {}</code>  <code>class-attribute</code>","text":"<p>Initialization Methods</p>"},{"location":"reference/nagata/core/#nagata.core.FileFramework","title":"<code>FileFramework</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Default values and classes for file management</p> <p>Every attribute in FilingFramework should be a class attribute so that it is accessible without instancing it (which it cannot be).</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>ClassVar[dict[Hashable, Any]]</code> <p>default settings for  file management.</p> <code>{'file_encoding': 'windows-1252', 'index_column': False, 'header': 'infer', 'conserve_memory': False, 'test_size': 1000, 'threads': -1, 'visual_tightness': 'tight', 'visual_format': 'png'}</code>"},{"location":"reference/nagata/core/#nagata.core.FileManager","title":"<code>FileManager</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>File and folder management for nagata.</p> <p>Creates and stores dynamic and static file paths, properly formats files for import and export, and provides methods for loading and saving nagata, pandas, and numpy objects.</p> <p>Parameters:</p> Name Type Description Default <code>root_folder</code> <code>Path | str</code> <p>the complete path from which the  other paths and folders used by FileManager are ordinarily derived  (unless you decide to use full paths for all other options).  Defaults to None. If not passed, the parent folder of the current  working workery is used.</p> <code>pathlib.Path('.')</code> <code>input_folder</code> <code>pathlib.Path | str]</code> <p>the input_folder subfolder  name or a complete path if the 'input_folder' is not off of 'root_folder'. Defaults to 'input'.</p> <code>'root'</code> <code>output_folder</code> <code>pathlib.Path | str]</code> <p>the output_folder subfolder name or a complete path if the 'output_folder' is not off of 'root_folder'. Defaults to 'output'.</p> <code>'root'</code> <code>framework</code> <code>Type[FileFramework]</code> <p>class with default settings, dict of supported file formats, and any other information needed for file management. Defaults to FileFramework.</p> <code>FileFramework</code>"},{"location":"reference/nagata/core/#nagata.core.FileManager.extensions","title":"<code>extensions: dict[str, str]</code>  <code>property</code>","text":"<p>Returns dict of file extensions.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>when a non-string or non-sequence is discovered in a stored FileFormat's 'extensions' attribute.</p> <p>Returns:     dict[str, str]: keys are file extensions and values are the related         key to the file_format in the 'formats' attribute.</p>"},{"location":"reference/nagata/core/#nagata.core.FileManager.framework","title":"<code>framework: Type[FileFramework] = FileFramework</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Initialization Methods</p>"},{"location":"reference/nagata/core/#nagata.core.FileManager._combine_path","title":"<code>_combine_path(folder, file_name=None, extension=None)</code>","text":"<p>Converts strings to pathlib Path object.</p> <p>If 'folder' matches an attribute, the value stored in that attribute is substituted for 'folder'.</p> <p>If 'name' and 'extension' are passed, a file path is created. Otherwise, a folder path is created.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>folder for file location.</p> required <code>name</code> <code>str</code> <p>the name of the file.</p> required <code>extension</code> <code>str</code> <p>the extension of the file.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>formed from string arguments.</p> Source code in <code>src/nagata/core.py</code> <pre><code>def _combine_path(\n    self,\n    folder: str,\n    file_name: Optional[str] = None,\n    extension: Optional[str] = None) -&gt; pathlib.Path:\n\"\"\"Converts strings to pathlib Path object.\n\n    If 'folder' matches an attribute, the value stored in that attribute\n    is substituted for 'folder'.\n\n    If 'name' and 'extension' are passed, a file path is created. Otherwise,\n    a folder path is created.\n\n    Args:\n        folder (str): folder for file location.\n        name (str): the name of the file.\n        extension (str): the extension of the file.\n\n    Returns:\n        Path: formed from string arguments.\n\n    \"\"\"\n    if hasattr(self, f'{folder}_folder'):\n        folder = getattr(self, f'{folder}_folder')\n    if file_name and extension and '.' not in file_name:\n        return pathlib.Path(folder).joinpath(f'{file_name}.{extension}')\n    elif file_name and '.' in file_name:\n        return pathlib.Path(folder).joinpath(file_name)\n    else:\n        return pathlib.Path(folder)\n</code></pre>"},{"location":"reference/nagata/core/#nagata.core.FileManager._get_extension","title":"<code>_get_extension(file_format)</code>","text":"<p>Returns a str file extension.</p> <p>Parameters:</p> Name Type Description Default <code>file_format</code> <code>str | FileFormat</code> <p>name of file format or a FileFormat  instance.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>if 'file_format' is a str but does not match any known file format in 'framework.formats'.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>file extension to use.</p> Source code in <code>src/nagata/core.py</code> <pre><code>def _get_extension(self, file_format: str | FileFormat) -&gt; str:\n\"\"\"Returns a str file extension.\n\n    Args:\n        file_format (str | FileFormat): name of file format or a FileFormat \n            instance.\n\n    Raises:\n        KeyError: if 'file_format' is a str but does not match any known\n            file format in 'framework.formats'.\n\n    Returns:\n        str: file extension to use.\n\n    \"\"\"\n    if isinstance(file_format, str):\n        try:\n            file_format = self.framework.formats[file_format]\n        except KeyError:\n            raise KeyError(f'{file_format} is not a recognized file format')\n    if isinstance(file_format.extensions, str):\n        return file_format.extensions\n    else:\n        return file_format.extensions[0]\n</code></pre>"},{"location":"reference/nagata/core/#nagata.core.FileManager._get_transfer_parameters","title":"<code>_get_transfer_parameters(file_format, transfer_type, **kwargs)</code>","text":"<p>Creates complete parameters for a file input/output method.</p> <p>Parameters:</p> Name Type Description Default <code>file_format</code> <code>FileFormat</code> <p>an instance with information about the needed and optional parameters.</p> required <code>kwargs</code> <code>Any</code> <p>additional parameters to pass to an input/output method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>MutableMapping[Hashable, Any]</code> <p>MutableMapping[Hashable, Any]: parameters to be passed to an  input/output method.</p> Source code in <code>src/nagata/core.py</code> <pre><code>def _get_transfer_parameters(\n    self,\n    file_format: FileFormat, \n    transfer_type: str,\n    **kwargs: Any) -&gt; MutableMapping[Hashable, Any]:\n\"\"\"Creates complete parameters for a file input/output method.\n\n    Args:\n        file_format (FileFormat): an instance with information about the\n            needed and optional parameters.\n        kwargs: additional parameters to pass to an input/output method.\n\n    Returns:\n        MutableMapping[Hashable, Any]: parameters to be passed to an \n            input/output method.\n\n    \"\"\"\n    parameters = getattr(file_format, f'{transfer_type}_parameters')\n    if parameters:\n        for specific, common in parameters.items():\n            if specific not in kwargs:\n                kwargs[specific] = self.framework.settings[common]\n    return kwargs # type: ignore\n</code></pre>"},{"location":"reference/nagata/core/#nagata.core.FileManager._prepare_transfer","title":"<code>_prepare_transfer(file_path, folder, file_name, transfer_type, file_format=None)</code>","text":"<p>Prepares file path related arguments for loading or saving a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[str, Path]]</code> <p>a complete file path. Defaults to  None.</p> required <code>folder</code> <code>Union[str, Path]]</code> <p>a complete folder path or the name of a  folder. Defaults to None.</p> required <code>file_name</code> <code>str</code> <p>file name without extension. Defaults to None.</p> required <code>file_format</code> <code>Union[str, FileFormat]]</code> <p>object with information about  how the file should be loaded or the key to such an object.  Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[Path, FileFormat]</code> <p>of a completed Path instance and FileFormat instance.</p> Source code in <code>src/nagata/core.py</code> <pre><code>def _prepare_transfer( \n    self,\n    file_path: pathlib.Path | str,\n    folder: pathlib.Path | str,\n    file_name: str,\n    transfer_type: str,\n    file_format: Optional[str | FileFormat] = None) -&gt; (\n        tuple[pathlib.Path, FileFormat]):\n\"\"\"Prepares file path related arguments for loading or saving a file.\n\n    Args:\n        file_path (Union[str, Path]]): a complete file path. Defaults to \n            None.\n        folder (Union[str, Path]]): a complete folder path or the name of a \n            folder. Defaults to None.\n        file_name (str): file name without extension. Defaults to None.\n        file_format (Union[str, FileFormat]]): object with information about \n            how the file should be loaded or the key to such an object. \n            Defaults to None.\n\n    Returns:\n        tuple: of a completed Path instance and FileFormat instance.\n\n    \"\"\"\n    extension = None\n    if file_path:\n        file_path = self.validate(path = file_path)\n        extension = file_path.suffix[1:] \n    elif file_name and '.' in file_name:\n        extension = camina.cleave_str(file_name, divider = '.')[-1]\n    if extension and not file_format:\n        file_format = self.extensions[extension]    \n    file_format = self._validate_file_format(file_format = file_format)\n    extension = extension or self._get_extension(file_format = file_format)\n    if not folder:\n        if transfer_type == 'save':\n            folder = self.output_folder\n        elif transfer_type == 'load':\n            folder = self.input_folder\n        else:\n            raise ValueError(\n                'either folder or transfer type must be passed')\n    if not file_path:\n        file_path = self._combine_path(\n            folder = folder, \n            file_name = file_name,\n            extension = extension)\n    return file_path, file_format\n</code></pre>"},{"location":"reference/nagata/core/#nagata.core.FileManager._validate_file_format","title":"<code>_validate_file_format(file_format)</code>","text":"<p>Selects 'file_format' or returns FileFormat instance intact.</p> <p>Parameters:</p> Name Type Description Default <code>file_format</code> <code>Union[str, FileFormat]</code> <p>name of file format or a FileFormat instance.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>if 'file_format' is a str but does not match any known file format in 'framework.formats'.</p> <code>TypeError</code> <p>if 'file_format' is neither a str nor FileFormat type.</p> <p>Returns:</p> Name Type Description <code>FileFormat</code> <code>FileFormat</code> <p>appropriate instance.</p> Source code in <code>src/nagata/core.py</code> <pre><code>def _validate_file_format(\n    self,\n    file_format: str | FileFormat) -&gt; FileFormat:\n\"\"\"Selects 'file_format' or returns FileFormat instance intact.\n\n    Args:\n        file_format (Union[str, FileFormat]): name of file format or a\n            FileFormat instance.\n\n    Raises:\n        KeyError: if 'file_format' is a str but does not match any known\n            file format in 'framework.formats'.\n        TypeError: if 'file_format' is neither a str nor FileFormat type.\n\n    Returns:\n        FileFormat: appropriate instance.\n\n    \"\"\"\n    if isinstance(file_format, str):\n        try:\n            return self.framework.formats[file_format]\n        except KeyError:\n            raise KeyError(f'{file_format} is not a recognized file format')\n    elif isinstance(file_format, FileFormat):\n        return file_format\n    else:\n        raise TypeError(f'{file_format} is not a FileFormat type')\n</code></pre>"},{"location":"reference/nagata/core/#nagata.core.FileManager._validate_io_folder","title":"<code>_validate_io_folder(path)</code>","text":"<p>Validates an import and export path.'</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>path to validate.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>pathlib.Path: path in a pathlib.Path format.</p> Source code in <code>src/nagata/core.py</code> <pre><code>def _validate_io_folder(self, path: str | pathlib.Path) -&gt; pathlib.Path:\n\"\"\"Validates an import and export path.'\n\n    Args:\n        path (str | pathlib.Path): path to validate.\n\n    Returns:\n        pathlib.Path: path in a pathlib.Path format.\n\n    \"\"\"\n    if isinstance(path, str):\n        attribute = f'{path}_folder'\n        try:\n            path = getattr(self, attribute)\n        except AttributeError:\n            pass\n    if isinstance(path, str): \n        path = self.root_folder.joinpath(path) \n    return path      \n</code></pre>"},{"location":"reference/nagata/core/#nagata.core.FileManager._validate_io_folders","title":"<code>_validate_io_folders()</code>","text":"<p>Validates all import and export paths.</p> Source code in <code>src/nagata/core.py</code> <pre><code>def _validate_io_folders(self) -&gt; None:\n\"\"\"Validates all import and export paths.\"\"\"\n    all_attributes = miller.name_variables(item = self)\n    io_attributes = [a for a in all_attributes if a.endswith('_folder')]\n    for attribute in io_attributes:\n        value = getattr(self, attribute)\n        path = self._validate_io_folder(path = value)\n        setattr(self, attribute, path)\n        self._write_folder(folder = path)\n    return\n</code></pre>"},{"location":"reference/nagata/core/#nagata.core.FileManager._validate_root_folder","title":"<code>_validate_root_folder()</code>","text":"<p>Validates the root folder path.</p> Source code in <code>src/nagata/core.py</code> <pre><code>def _validate_root_folder(self) -&gt; None:\n\"\"\"Validates the root folder path.\"\"\"\n    self.root_folder = self.validate(path = self.root_folder)\n    self._write_folder(folder = self.root_folder)\n    return\n</code></pre>"},{"location":"reference/nagata/core/#nagata.core.FileManager._write_folder","title":"<code>_write_folder(folder)</code>","text":"<p>Writes folder to disk.</p> <p>Parent folders are created as needed.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>Union[str, Path]</code> <p>intended folder to write to disk.</p> required Source code in <code>src/nagata/core.py</code> <pre><code>def _write_folder(self, folder: pathlib.Path | str) -&gt; None:\n\"\"\"Writes folder to disk.\n\n    Parent folders are created as needed.\n\n    Args:\n        folder (Union[str, Path]): intended folder to write to disk.\n\n    \"\"\"\n    pathlib.Path.mkdir(folder, parents = True, exist_ok = True)\n    return\n</code></pre>"},{"location":"reference/nagata/core/#nagata.core.FileManager.load","title":"<code>load(file_path=None, folder=None, file_name=None, file_format=None, **kwargs)</code>","text":"<p>Imports file by calling appropriate method based on file_format.</p> <p>If needed arguments are not passed, default values are used. If file_path is passed, folder and file_name are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[str, Path]]</code> <p>a complete file path. Defaults to  None.</p> <code>None</code> <code>folder</code> <code>Union[str, Path]]</code> <p>a complete folder path or the name of a  folder. Defaults to None.</p> <code>None</code> <code>file_name</code> <code>str</code> <p>file name without extension. Defaults to None.</p> <code>None</code> <code>file_format</code> <code>Union[str, FileFormat]]</code> <p>object with information about  how the file should be loaded or the key to such an object.  Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>can be passed if additional options are desired specific to the methods attached to a FileFormat instance.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>depending upon method used for appropriate file format, a new variable of a supported type is returned.</p> Source code in <code>src/nagata/core.py</code> <pre><code>def load(\n    self,\n    file_path: Optional[pathlib.Path | str] = None,\n    folder: pathlib.Path | str = None,\n    file_name: Optional[str] = None,\n    file_format: Optional[str | FileFormat] = None,\n    **kwargs: Any) -&gt; Any:\n\"\"\"Imports file by calling appropriate method based on file_format.\n\n    If needed arguments are not passed, default values are used. If\n    file_path is passed, folder and file_name are ignored.\n\n    Args:\n        file_path (Union[str, Path]]): a complete file path. Defaults to \n            None.\n        folder (Union[str, Path]]): a complete folder path or the name of a \n            folder. Defaults to None.\n        file_name (str): file name without extension. Defaults to None.\n        file_format (Union[str, FileFormat]]): object with information about \n            how the file should be loaded or the key to such an object. \n            Defaults to None.\n        **kwargs: can be passed if additional options are desired specific\n            to the methods attached to a FileFormat instance.\n\n    Returns:\n        Any: depending upon method used for appropriate file format, a new\n            variable of a supported type is returned.\n\n    \"\"\"\n    file_path, file_format = self._prepare_transfer(\n        file_path = file_path,\n        folder = folder,\n        file_name = file_name,\n        transfer_type = 'load',\n        file_format = file_format)\n    parameters = self._get_transfer_parameters(\n        file_format = file_format, \n        transfer_type = 'load',\n        **kwargs)\n    return file_format.load(path = file_path, **parameters)\n</code></pre>"},{"location":"reference/nagata/core/#nagata.core.FileManager.save","title":"<code>save(item, file_path=None, folder=None, file_name=None, file_format=None, **kwargs)</code>","text":"<p>Exports file by calling appropriate method based on file_format.</p> <p>If needed arguments are not passed, default values are used. If file_path is passed, folder and file_name are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>object to be save to disk.</p> required <code>file_path</code> <code>Union[str, Path]]</code> <p>a complete file path. Defaults to  None.</p> <code>None</code> <code>folder</code> <code>Union[str, Path]]</code> <p>a complete folder path or the name of a  folder. Defaults to None.</p> <code>None</code> <code>file_name</code> <code>str</code> <p>file name without extension. Defaults to None.</p> <code>None</code> <code>file_format</code> <code>Union[str, FileFormat]]</code> <p>object with information about  how the file should be loaded or the key to such an object.  Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>can be passed if additional options are desired specific to the methods attached to a FileFormat instance.</p> <code>{}</code> Source code in <code>src/nagata/core.py</code> <pre><code>def save(\n    self,\n    item: Any,\n    file_path: Optional[pathlib.Path | str] = None,\n    folder: Optional[pathlib.Path | str] = None,\n    file_name: Optional[str] = None,\n    file_format: Optional[str | FileFormat] = None,\n    **kwargs: Any) -&gt; None:\n\"\"\"Exports file by calling appropriate method based on file_format.\n\n    If needed arguments are not passed, default values are used. If\n    file_path is passed, folder and file_name are ignored.\n\n    Args:\n        item (Any): object to be save to disk.\n        file_path (Union[str, Path]]): a complete file path. Defaults to \n            None.\n        folder (Union[str, Path]]): a complete folder path or the name of a \n            folder. Defaults to None.\n        file_name (str): file name without extension. Defaults to None.\n        file_format (Union[str, FileFormat]]): object with information about \n            how the file should be loaded or the key to such an object. \n            Defaults to None.\n        **kwargs: can be passed if additional options are desired specific\n            to the methods attached to a FileFormat instance.\n\n    \"\"\"\n    file_path, file_format = self._prepare_transfer(\n        file_path = file_path,\n        folder = folder,\n        file_name = file_name,\n        transfer_type = 'save',\n        file_format = file_format)\n    parameters = self._get_transfer_parameters(\n        file_format = file_format, \n        transfer_type = 'save',\n        **kwargs)\n    file_format.save(item = item, path = file_path, **parameters)\n    return\n</code></pre>"},{"location":"reference/nagata/core/#nagata.core.FileManager.validate","title":"<code>validate(path)</code>","text":"<p>Turns 'file_path' into a pathlib.Path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>str or Path to be validated. If a str is passed, the method will see if an attribute matching 'path' exists and if that attribute contains a Path.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'path' is neither a str nor Path.</p> <code>FileNotFoundError</code> <p>if the validated path does not exist and 'create' is False.</p> <p>Returns:</p> Type Description <code>Path</code> <p>pathlib.Path: derived from 'path'.</p> Source code in <code>src/nagata/core.py</code> <pre><code>def validate(self, path: pathlib.Path | str) -&gt; pathlib.Path:\n\"\"\"Turns 'file_path' into a pathlib.Path.\n\n    Args:\n        path (pathlib.Path | str): str or Path to be validated. If\n            a str is passed, the method will see if an attribute matching\n            'path' exists and if that attribute contains a Path.\n\n    Raises:\n        TypeError: if 'path' is neither a str nor Path.\n        FileNotFoundError: if the validated path does not exist and 'create'\n            is False.\n\n    Returns:\n        pathlib.Path: derived from 'path'.\n\n    \"\"\"\n    if isinstance(path, str):\n        attribute = f'{path}_folder'\n        try:\n            value = getattr(self, attribute)\n            if isinstance(value, pathlib.Path):\n                return value\n        except AttributeError:\n            pass\n        else:\n            return pathlib.Path(path)\n    elif isinstance(path, pathlib.Path):\n        return path\n    else:\n        raise TypeError(f'path must be a str or Path type')\n    return\n</code></pre>"},{"location":"reference/nagata/formats/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> formats","text":"<p>formats: default file formats included out of the box. Corey Rayburn Yung coreyrayburnyung@gmail.com Copyright 2020-2022, Corey Rayburn Yung License: Apache-2.0</p> <pre><code>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> Contents <p>Default FileFormat instances. They are not assigned to any values or dict     because the act of instancing causes them to be stored in      'FileFramework.formats'.</p> <p>ToDo:</p>"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatCSV","title":"<code>FileFormatCSV</code>  <code>dataclass</code>","text":"<p>             Bases: <code>FileFormatPandas</code></p> <p>File format information, loader, and saver.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>Optional[Union[str, Sequence[str]]]</code> <p>str file extension(s) associated with the format. If more than one is listed, the first  one is used for saving new files and all will be used for loading.  Defaults to None.</p> <code>'csv'</code> <code>parameters</code> <code>Mapping[str, str]]</code> <p>shared parameters to use from the pool  of settings in FileFramework.settings where the key is the parameter  name that the load or save method should use and the value is the  key for the argument in the shared parameters. Defaults to an empty  dict.</p> required"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatExcel","title":"<code>FileFormatExcel</code>  <code>dataclass</code>","text":"<p>             Bases: <code>FileFormatPandas</code></p> <p>File format information, loader, and saver.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>Optional[Union[str, Sequence[str]]]</code> <p>str file extension(s) associated with the format. If more than one is listed, the first  one is used for saving new files and all will be used for loading.  Defaults to None.</p> <code>('xlsx', 'xls')</code> <code>parameters</code> <code>Mapping[str, str]]</code> <p>shared parameters to use from the pool  of settings in FileFramework.settings where the key is the parameter  name that the load or save method should use and the value is the  key for the argument in the shared parameters. Defaults to an empty  dict.</p> required"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatFeather","title":"<code>FileFormatFeather</code>  <code>dataclass</code>","text":"<p>             Bases: <code>FileFormatPandas</code></p> <p>File format information, loader, and saver.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>Optional[Union[str, Sequence[str]]]</code> <p>str file extension(s) associated with the format. If more than one is listed, the first  one is used for saving new files and all will be used for loading.  Defaults to None.</p> <code>'feather'</code> <code>parameters</code> <code>Mapping[str, str]]</code> <p>shared parameters to use from the pool  of settings in FileFramework.settings where the key is the parameter  name that the load or save method should use and the value is the  key for the argument in the shared parameters. Defaults to an empty  dict.</p> required"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatHDF","title":"<code>FileFormatHDF</code>  <code>dataclass</code>","text":"<p>             Bases: <code>FileFormatPandas</code></p> <p>File format information, loader, and saver.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>Optional[Union[str, Sequence[str]]]</code> <p>str file extension(s) associated with the format. If more than one is listed, the first  one is used for saving new files and all will be used for loading.  Defaults to None.</p> <code>('hdf', 'hdf5')</code> <code>parameters</code> <code>Mapping[str, str]]</code> <p>shared parameters to use from the pool  of settings in FileFramework.settings where the key is the parameter  name that the load or save method should use and the value is the  key for the argument in the shared parameters. Defaults to an empty  dict.</p> required"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatJSON","title":"<code>FileFormatJSON</code>  <code>dataclass</code>","text":"<p>             Bases: <code>FileFormatPandas</code></p> <p>File format information, loader, and saver.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>Optional[Union[str, Sequence[str]]]</code> <p>str file extension(s) associated with the format. If more than one is listed, the first  one is used for saving new files and all will be used for loading.  Defaults to None.</p> <code>'json'</code> <code>parameters</code> <code>Mapping[str, str]]</code> <p>shared parameters to use from the pool  of settings in FileFramework.settings where the key is the parameter  name that the load or save method should use and the value is the  key for the argument in the shared parameters. Defaults to an empty  dict.</p> required"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatLatex","title":"<code>FileFormatLatex</code>  <code>dataclass</code>","text":"<p>             Bases: <code>FileFormatPandas</code></p> <p>File format information, loader, and saver.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>Optional[Union[str, Sequence[str]]]</code> <p>str file extension(s) associated with the format. If more than one is listed, the first  one is used for saving new files and all will be used for loading.  Defaults to None.</p> <code>'latex'</code> <code>parameters</code> <code>Mapping[str, str]]</code> <p>shared parameters to use from the pool  of settings in FileFramework.settings where the key is the parameter  name that the load or save method should use and the value is the  key for the argument in the shared parameters. Defaults to an empty  dict.</p> required"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatPNG","title":"<code>FileFormatPNG</code>  <code>dataclass</code>","text":"<p>             Bases: <code>FileFormatSeaborn</code></p> <p>File format information, loader, and saver.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>Optional[Union[str, Sequence[str]]]</code> <p>str file extension(s) associated with the format. If more than one is listed, the first  one is used for saving new files and all will be used for loading.  Defaults to None.</p> <code>'png'</code> <code>parameters</code> <code>Mapping[str, str]]</code> <p>shared parameters to use from the pool  of settings in FileFramework.settings where the key is the parameter  name that the load or save method should use and the value is the  key for the argument in the shared parameters. Defaults to an empty  dict.</p> required"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatPandas","title":"<code>FileFormatPandas</code>  <code>dataclass</code>","text":"<p>             Bases: <code>FileFormat</code>, <code>ABC</code></p> <p>File format information, loader, and saver.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>Optional[Union[str, Sequence[str]]]</code> <p>str file extension(s) associated with the format. If more than one is listed, the first  one is used for saving new files and all will be used for loading.  Defaults to None.</p> <code>None</code> <code>parameters</code> <code>Mapping[str, str]]</code> <p>shared parameters to use from the pool  of settings in FileFramework.settings where the key is the parameter  name that the load or save method should use and the value is the  key for the argument in the shared parameters. Defaults to an empty  dict.</p> required"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatPandas.saver","title":"<code>saver: str = None</code>  <code>class-attribute</code>","text":"<p>Public Methods</p>"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatPandas.load","title":"<code>load(path, **kwargs)</code>","text":"<p>Loads a file to a pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>path to pandas dataframe.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if 'loader' is None.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>pandas dataframe.</p> Source code in <code>src/nagata/formats.py</code> <pre><code>def load(self, path: pathlib.Path | str, **kwargs) -&gt; object:\n\"\"\"Loads a file to a pandas dataframe.\n\n    Args:\n        path (pathlib.Path | str): path to pandas dataframe.\n\n    Raises:\n        NotImplementedError: if 'loader' is None.\n\n    Returns:\n        object: pandas dataframe.\n\n    \"\"\"\n\n    if self.loader is None:\n        raise NotImplementedError(\n            'pandas does not support loading for this data type')\n    else:\n        if 'pandas' not in sys.modules:\n            import pandas \n        loader = getattr(pandas, self.loader)\n        return loader(path, **kwargs)\n</code></pre>"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatPandas.save","title":"<code>save(item, path, **kwargs)</code>","text":"<p>Saves dataframe 'item' to a file at 'path'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>pandas dataframe.</p> required <code>path</code> <code>Path | str</code> <p>path to which 'item' should be saved.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if 'saver' is None.</p> Source code in <code>src/nagata/formats.py</code> <pre><code>def save(self, item: object, path: pathlib.Path | str, **kwargs) -&gt; None:\n\"\"\"Saves dataframe 'item' to a file at 'path'.\n\n    Args:\n        item (object): pandas dataframe.\n        path (pathlib.Path | str): path to which 'item' should be saved.\n\n    Raises:\n        NotImplementedError: if 'saver' is None.\n\n    \"\"\" \n    if self.saver is None:\n        raise NotImplementedError(\n            'pandas does not support saving to this data type')   \n    else:\n        saver = getattr(item, self.saver)\n        saver(path, **kwargs)\n    return   \n</code></pre>"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatParquet","title":"<code>FileFormatParquet</code>  <code>dataclass</code>","text":"<p>             Bases: <code>FileFormatPandas</code></p> <p>File format information, loader, and saver.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>Optional[Union[str, Sequence[str]]]</code> <p>str file extension(s) associated with the format. If more than one is listed, the first  one is used for saving new files and all will be used for loading.  Defaults to None.</p> <code>'parquet'</code> <code>parameters</code> <code>Mapping[str, str]]</code> <p>shared parameters to use from the pool  of settings in FileFramework.settings where the key is the parameter  name that the load or save method should use and the value is the  key for the argument in the shared parameters. Defaults to an empty  dict.</p> required"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatPickle","title":"<code>FileFormatPickle</code>  <code>dataclass</code>","text":"<p>             Bases: <code>FileFormat</code></p> <p>File format information, loader, and saver.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>Optional[Union[str, Sequence[str]]]</code> <p>str file extension(s) associated with the format. If more than one is listed, the first  one is used for saving new files and all will be used for loading.  Defaults to None.</p> <code>('pickle', 'pkl')</code> <code>parameters</code> <code>Mapping[str, str]]</code> <p>shared parameters to use from the pool  of settings in FileFramework.settings where the key is the parameter  name that the load or save method should use and the value is the  key for the argument in the shared parameters. Defaults to an empty  dict.</p> required"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatPickle.load","title":"<code>load(path, **kwargs)</code>","text":"<p>Loads a pickled object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>path to a pickled object.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>item loaded from 'path'.</p> Source code in <code>src/nagata/formats.py</code> <pre><code>def load(self, path: pathlib.Path | str, **kwargs) -&gt; object:\n\"\"\"Loads a pickled object.\n\n    Args:\n        path (pathlib.Path | str): path to a pickled object.\n\n    Returns:\n        object: item loaded from 'path'.\n\n    \"\"\"   \n    a_file = open(path, 'r', **kwargs)\n    if 'pickle' not in sys.modules:\n        import pickle\n    loaded = pickle.load(a_file)\n    a_file.close()\n    return loaded\n</code></pre>"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatPickle.save","title":"<code>save(item, path, **kwargs)</code>","text":"<p>Pickles 'item' at 'path.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to pickle.</p> required <code>path</code> <code>Path | str</code> <p>path where 'item' should be pickled</p> required Source code in <code>src/nagata/formats.py</code> <pre><code>def save(self, item: Any, path: pathlib.Path | str, **kwargs) -&gt; None:\n\"\"\"Pickles 'item' at 'path.\n\n    Args:\n        item (Any): item to pickle.\n        path (pathlib.Path | str): path where 'item' should be pickled\n\n    \"\"\"   \n    a_file = open(path, 'w', **kwargs)\n    if 'pickle' not in sys.modules:\n        import pickle\n    pickle.dump(item, a_file)\n    a_file.close()\n    return\n</code></pre>"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatSQL","title":"<code>FileFormatSQL</code>  <code>dataclass</code>","text":"<p>             Bases: <code>FileFormatPandas</code></p> <p>File format information, loader, and saver.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>Optional[Union[str, Sequence[str]]]</code> <p>str file extension(s) associated with the format. If more than one is listed, the first  one is used for saving new files and all will be used for loading.  Defaults to None.</p> <code>'sql'</code> <code>parameters</code> <code>Mapping[str, str]]</code> <p>shared parameters to use from the pool  of settings in FileFramework.settings where the key is the parameter  name that the load or save method should use and the value is the  key for the argument in the shared parameters. Defaults to an empty  dict.</p> required"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatSTATA","title":"<code>FileFormatSTATA</code>  <code>dataclass</code>","text":"<p>             Bases: <code>FileFormatPandas</code></p> <p>File format information, loader, and saver.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>Optional[Union[str, Sequence[str]]]</code> <p>str file extension(s) associated with the format. If more than one is listed, the first  one is used for saving new files and all will be used for loading.  Defaults to None.</p> <code>'dta'</code> <code>parameters</code> <code>Mapping[str, str]]</code> <p>shared parameters to use from the pool  of settings in FileFramework.settings where the key is the parameter  name that the load or save method should use and the value is the  key for the argument in the shared parameters. Defaults to an empty  dict.</p> required"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatSeaborn","title":"<code>FileFormatSeaborn</code>  <code>dataclass</code>","text":"<p>             Bases: <code>FileFormat</code>, <code>ABC</code></p> <p>File format information, loader, and saver.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>Optional[Union[str, Sequence[str]]]</code> <p>str file extension(s) associated with the format. If more than one is listed, the first  one is used for saving new files and all will be used for loading.  Defaults to None.</p> <code>None</code> <code>parameters</code> <code>Mapping[str, str]]</code> <p>shared parameters to use from the pool  of settings in FileFramework.settings where the key is the parameter  name that the load or save method should use and the value is the  key for the argument in the shared parameters. Defaults to an empty  dict.</p> required"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatSeaborn.saver","title":"<code>saver: str = None</code>  <code>class-attribute</code>","text":"<p>Public Methods</p>"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatSeaborn.load","title":"<code>load(path, **kwargs)</code>","text":"<p>Loads a file to a pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>path to pandas dataframe.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if 'loader' is None.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>pandas dataframe.</p> Source code in <code>src/nagata/formats.py</code> <pre><code>def load(self, path: pathlib.Path | str, **kwargs) -&gt; object:\n\"\"\"Loads a file to a pandas dataframe.\n\n    Args:\n        path (pathlib.Path | str): path to pandas dataframe.\n\n    Raises:\n        NotImplementedError: if 'loader' is None.\n\n    Returns:\n        object: pandas dataframe.\n\n    \"\"\"\n\n    if self.loader is None:\n        raise NotImplementedError(\n            'seaborn does not support loading for this data type')\n    else:\n        if 'seaborn' not in sys.modules:\n            import seaborn\n        loader = getattr(seaborn, self.loader)\n        return loader(path, **kwargs)\n</code></pre>"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatSeaborn.save","title":"<code>save(item, path, **kwargs)</code>","text":"<p>Saves dataframe 'item' to a file at 'path'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>object</code> <p>pandas dataframe.</p> required <code>path</code> <code>Path | str</code> <p>path to which 'item' should be saved.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if 'saver' is None.</p> Source code in <code>src/nagata/formats.py</code> <pre><code>def save(self, item: object, path: pathlib.Path | str, **kwargs) -&gt; None:\n\"\"\"Saves dataframe 'item' to a file at 'path'.\n\n    Args:\n        item (object): pandas dataframe.\n        path (pathlib.Path | str): path to which 'item' should be saved.\n\n    Raises:\n        NotImplementedError: if 'saver' is None.\n\n    \"\"\" \n    if self.saver is None:\n        raise NotImplementedError(\n            'seaborn does not support saving to this data type')   \n    else:\n        saver = getattr(item, self.saver)\n        saver(path, **kwargs)\n    return    \n</code></pre>"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatText","title":"<code>FileFormatText</code>  <code>dataclass</code>","text":"<p>             Bases: <code>FileFormat</code></p> <p>File format information, loader, and saver.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>Optional[Union[str, Sequence[str]]]</code> <p>str file extension(s) associated with the format. If more than one is listed, the first  one is used for saving new files and all will be used for loading.  Defaults to None.</p> <code>('txt', 'text')</code> <code>parameters</code> <code>Mapping[str, str]]</code> <p>shared parameters to use from the pool  of settings in FileFramework.settings where the key is the parameter  name that the load or save method should use and the value is the  key for the argument in the shared parameters. Defaults to an empty  dict.</p> required"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatText.save_parameters","title":"<code>save_parameters: Optional[Mapping[str, str]] = {}</code>  <code>class-attribute</code>","text":"<p>Public Methods</p>"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatText.load","title":"<code>load(path, **kwargs)</code>","text":"<p>Loads a text file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>path to text file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>Any</code> <p>text contained within the loaded file.</p> Source code in <code>src/nagata/formats.py</code> <pre><code>def load(self, path: pathlib.Path | str, **kwargs) -&gt; Any:\n\"\"\"Loads a text file.\n\n    Args:\n        path (pathlib.Path | str): path to text file.\n\n    Returns:\n        str: text contained within the loaded file.\n\n    \"\"\"    \n    a_file = open(path, 'r', **kwargs)\n    loaded = a_file.read()\n    a_file.close()\n    return loaded\n</code></pre>"},{"location":"reference/nagata/formats/#nagata.formats.FileFormatText.save","title":"<code>save(item, path, **kwargs)</code>","text":"<p>Saves str 'item' to a file at 'path'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>str item to save to a text file.</p> required <code>path</code> <code>Path | str</code> <p>path to which 'item' should be saved.</p> required Source code in <code>src/nagata/formats.py</code> <pre><code>def save(self, item: Any, path: pathlib.Path | str, **kwargs) -&gt; None:\n\"\"\"Saves str 'item' to a file at 'path'.\n\n    Args:\n        item (str): str item to save to a text file.\n        path (pathlib.Path | str): path to which 'item' should be saved.\n\n    \"\"\"    \n    a_file = open(path, 'w', **kwargs)\n    a_file.write(item)\n    a_file.close()\n    return   \n</code></pre>"},{"location":"reference/nagata/lazy/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> lazy","text":"<p>lazy: lazy importing classes and functions Corey Rayburn Yung coreyrayburnyung@gmail.com Copyright 2020-2022, Corey Rayburn Yung License: Apache-2.0</p> <pre><code>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre> Contents <p>from_path: from_file_path: from_import_path: absolute_import: absolute_supackage_import: relative_import: relative_subpackage_import: from_importables: Importer (object): Delayed (object):</p> <p>ToDo:</p>"},{"location":"reference/nagata/lazy/#nagata.lazy.Delayed","title":"<code>Delayed</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Mixin that converts str attributes to imported items when accessed.</p>"},{"location":"reference/nagata/lazy/#nagata.lazy.Delayed--only-str-values-of-attributes-with-a-in-them-are-assumed-to-be-import","title":"Only str values of attributes with a '.' in them are assumed to be import","text":""},{"location":"reference/nagata/lazy/#nagata.lazy.Delayed--paths","title":"paths.","text":"<p>After an item is imported, it is assigned to the attribute which previously held the str import path so that it does not need to be reloaded.</p>"},{"location":"reference/nagata/lazy/#nagata.lazy.Importer","title":"<code>Importer</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Lazy importer that uses a dict to lazily import items.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>name of package to which the 'importables' are linked.</p> required <code>importables</code> <code>Optional[MutableMapping[str, str]]</code> <p>dict keys are names used to refer to importable item and values are the import paths of the importable items. Defaults to an empty dict.</p> <code>dataclasses.field(default_factory=dict)</code>"},{"location":"reference/nagata/lazy/#nagata.lazy.Importer.importables","title":"<code>importables: Optional[MutableMapping[str, str]] = dataclasses.field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Public Methods</p>"},{"location":"reference/nagata/lazy/#nagata.lazy.absolute_import","title":"<code>absolute_import(path, package)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>[description]</p> Source code in <code>src/nagata/lazy.py</code> <pre><code>def absolute_import(path: str, package: str) -&gt; Any:\n\"\"\"[summary]\n\n    Args:\n        path (str): [description]\n\n    Returns:\n        Any: [description]\n\n    \"\"\"\n    if path.startswith('.'):\n        path = path[1:]\n        return relative_subpackage_import(path = path)\n    return importlib.import_module(path)\n</code></pre>"},{"location":"reference/nagata/lazy/#nagata.lazy.absolute_subpackage_import","title":"<code>absolute_subpackage_import(path, package)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>[description]</p> required <code>package</code> <code>str</code> <p>[description]. </p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>[description]</p> Source code in <code>src/nagata/lazy.py</code> <pre><code>def absolute_subpackage_import(path: str, package: str) -&gt; Any:\n\"\"\"[summary]\n\n    Args:\n        path (str): [description]\n        package (str): [description]. \n\n    Returns:\n        Any: [description]\n\n    \"\"\"\n    if path.startswith('.'):\n        path = path[1:]\n        return relative_subpackage_import(path = path, package = package)\n    return importlib.import_module(path, package = package)\n</code></pre>"},{"location":"reference/nagata/lazy/#nagata.lazy.from_file_path","title":"<code>from_file_path(path, name=None)</code>","text":"<p>Imports and returns module from file path at 'name'.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>file path of module to load.</p> required <code>name</code> <code>Optional[str]</code> <p>name to store module at in 'sys.modules'. If it is None, the stem of 'path' is used. Defaults to None.</p> <code>None</code> <p>Returns:     types.ModuleType: imported module.</p> Source code in <code>src/nagata/lazy.py</code> <pre><code>def from_file_path(\n    path: pathlib.Path | str, \n    name: Optional[str] = None) -&gt; types.ModuleType:\n\"\"\"Imports and returns module from file path at 'name'.\n\n    Args:\n        path (pathlib.Path | str): file path of module to load.\n        name (Optional[str]): name to store module at in 'sys.modules'. If it\n            is None, the stem of 'path' is used. Defaults to None.\n    Returns:\n        types.ModuleType: imported module.\n\n    \"\"\"\n    if isinstance(path, str):\n        path = pathlib.Path(path)\n    if name is None:\n        name = path.stem\n    spec = importlib.util.spec_from_file_location(name, path)\n    if spec is None:\n        raise ImportError(f'Failed to create spec from {path}')\n    else:\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n        return module\n</code></pre>"},{"location":"reference/nagata/lazy/#nagata.lazy.from_import_path","title":"<code>from_import_path(path, package=None)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>[description]</p> required <code>package</code> <code>Optional[str]</code> <p>[description]. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>[description]</p> Source code in <code>src/nagata/lazy.py</code> <pre><code>def from_import_path(path: str, package: Optional[str] = None) -&gt; Any:\n\"\"\"[summary]\n\n    Args:\n        path (str): [description]\n        package (Optional[str], optional): [description]. Defaults to None.\n\n    Returns:\n        Any: [description]\n\n    \"\"\"\n    # if package and isinstance(path, str):\n    #     path = '.'.join([path, package])\n    print('test sys modules', 'pandas' in sys.modules)\n    print('test path package', path, package)\n    try:\n        return sys.modules[path]\n\n    except KeyError:\n        techniques = [\n            absolute_import,\n            absolute_subpackage_import,\n            relative_import,\n            relative_subpackage_import]\n        for technique in techniques:\n            try:\n                return technique(path, package)\n            except ModuleNotFoundError:\n                item = path.split('.')[-1]\n                module_name = path[:-len(item) - 1]\n                module = technique(module_name, package)\n                return getattr(module, item)  \n        raise ModuleNotFoundError(f'{path} could not be imported') \n</code></pre>"},{"location":"reference/nagata/lazy/#nagata.lazy.from_importables","title":"<code>from_importables(name, importables, package=None)</code>","text":"<p>Lazily imports modules and items within them.</p> <p>Lazy importing means that modules are only imported when they are first accessed. This can save memory and keep namespaces decluttered.</p> <p>This code is adapted from PEP 562: https://www.python.org/dev/peps/pep-0562/ which outlines how the decision to incorporate 'getattr' functions to  modules allows lazy loading. Rather than place this function solely within 'getattr', it is included here seprately so that it can easily be called  by 'init.py' files throughout nagata and by users (as  'nagata.load.from_dict').</p> <p>To effectively use 'from_dict' in an 'init.py' file, the user needs to  pass a 'importables' dict which indicates how users should accesss imported  modules and included items. This modules includes an example 'importables'  dict and how to easily add this function to a 'getattr' function.</p> <p>Instead of limiting its lazy imports to full import paths as the example in  PEP 562, this function has 2 major advantages:     1) It allows importing items within modules and not just modules. The         function first tries to import 'name' assuming it is a module. But          if that fails, it parses the last portion of 'name' and attempts to          import the preceding module and then returns the item within it.     2) It allows import paths that are less than the full import path by         using the 'importables' dict. 'importables' has keys which are the          name of the attribute being sought and values which are the full          import path (dropping the leading '.'). 'importables' thus acts as          the normal import block in an init.py file but insures that all          importing is done lazily.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of module or item within a module.</p> required <code>package</code> <code>str</code> <p>name of package from which the module is sought.</p> <code>None</code> <code>importables</code> <code>MutableMapping[str, str]</code> <p>keys are the access names for  items sought and values are the import path where the item is  actually located.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>if there is no module or item matching 'name' im  'importables'.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>a module or item stored within a module.</p> Source code in <code>src/nagata/lazy.py</code> <pre><code>def from_importables(\n    name: str, \n    importables: MutableMapping[str, str],\n    package: Optional[str] = None) -&gt; Any:\n\"\"\"Lazily imports modules and items within them.\n\n    Lazy importing means that modules are only imported when they are first\n    accessed. This can save memory and keep namespaces decluttered.\n\n    This code is adapted from PEP 562: https://www.python.org/dev/peps/pep-0562/\n    which outlines how the decision to incorporate '__getattr__' functions to \n    modules allows lazy loading. Rather than place this function solely within\n    '__getattr__', it is included here seprately so that it can easily be called \n    by '__init__.py' files throughout nagata and by users (as \n    'nagata.load.from_dict').\n\n    To effectively use 'from_dict' in an '__init__.py' file, the user needs to \n    pass a 'importables' dict which indicates how users should accesss imported \n    modules and included items. This modules includes an example 'importables' \n    dict and how to easily add this function to a '__getattr__' function.\n\n    Instead of limiting its lazy imports to full import paths as the example in \n    PEP 562, this function has 2 major advantages:\n        1) It allows importing items within modules and not just modules. The\n            function first tries to import 'name' assuming it is a module. But \n            if that fails, it parses the last portion of 'name' and attempts to \n            import the preceding module and then returns the item within it.\n        2) It allows import paths that are less than the full import path by\n            using the 'importables' dict. 'importables' has keys which are the \n            name of the attribute being sought and values which are the full \n            import path (dropping the leading '.'). 'importables' thus acts as \n            the normal import block in an __init__.py file but insures that all \n            importing is done lazily.\n\n    Args:\n        name (str): name of module or item within a module.\n        package (str): name of package from which the module is sought.\n        importables (MutableMapping[str, str]): keys are the access names for \n            items sought and values are the import path where the item is \n            actually located.\n\n    Raises:\n        AttributeError: if there is no module or item matching 'name' im \n            'importables'.\n\n    Returns:\n        Any: a module or item stored within a module.\n\n    \"\"\"\n    try:\n        return from_import_path(path = importables[name], package = package)\n    except KeyError:\n        raise KeyError(f'{name} is not in importables') \n</code></pre>"},{"location":"reference/nagata/lazy/#nagata.lazy.from_path","title":"<code>from_path(path, name=None)</code>","text":"<p>Imports and returns module from import or file path at 'name'.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>import or file path of module to load.</p> required <code>name</code> <code>Optional[str]</code> <p>name to store module at in 'sys.modules'. If it is None, the stem of 'path' is used. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> Source code in <code>src/nagata/lazy.py</code> <pre><code>def from_path(\n    path: pathlib.Path | str, \n    name: Optional[str] = None) -&gt; Any:\n\"\"\"Imports and returns module from import or file path at 'name'.\n\n    Args:\n        path (pathlib.Path | str): import or file path of module to load.\n        name (Optional[str]): name to store module at in 'sys.modules'. If it\n            is None, the stem of 'path' is used. Defaults to None.\n\n    Returns:\n        Any:\n\n    \"\"\"\n    if isinstance(path, pathlib.Path) or '\\\\' in path or '\\/' in path:\n        return from_file_path(path = path, name = name)\n    else:\n        return from_import_path(path = path)\n</code></pre>"},{"location":"reference/nagata/lazy/#nagata.lazy.relative_import","title":"<code>relative_import(path)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>[description]</p> Source code in <code>src/nagata/lazy.py</code> <pre><code>def relative_import(path: str) -&gt; Any:\n\"\"\"[summary]\n\n    Args:\n        path (str): [description]\n\n    Returns:\n        Any: [description]\n\n    \"\"\"\n    if not path.startswith('.'):\n        path = '.' + path\n    return importlib.import_module(sys.path_importer_cache)\n</code></pre>"},{"location":"reference/nagata/lazy/#nagata.lazy.relative_subpackage_import","title":"<code>relative_subpackage_import(path, package)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>[description]</p> required <code>package</code> <code>str</code> <p>[description]. </p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>[description]</p> Source code in <code>src/nagata/lazy.py</code> <pre><code>def relative_subpackage_import(path: str, package: str) -&gt; Any:\n\"\"\"[summary]\n\n    Args:\n        path (str): [description]\n        package (str): [description]. \n\n    Returns:\n        Any: [description]\n\n    \"\"\"\n    if not path.startswith('.'):\n        path = '.' + path\n    return importlib.import_module(path, package = package)\n</code></pre>"}]}